```{r setup, include=FALSE, echo=FALSE}
### Set knitr global options
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)

### Load libraries
library(data.table)
library(Seurat)
library(readr)
library(cowplot)
```

> **_NOTE:_**  Make sure the data is the unedited seurat file.

```{r, tidy='styler', tidy.opts=list(strict=FALSE)}
### First the seurat obect
seurat_analysed <- readRDS(file=params$dir_seurat)

### Change ident to original idents
Idents(seurat_analysed)<-seurat_analysed@meta.data[,params$qcs_indent_var]
```

## 1.1 - Quality Control
### Remove low quality cells 

Remove dead cells, doublets, and cells with low molecule counts
Examine the following 3 parameters:

1. `nFeature_RNA` is the number of genes detected in each cell. 
2. `nCount_RNA` is the total number of molecules detected within a cell
3. `percent.mt` is the percent of features that are mitochondrial genes

***
**NOTE** 

There are several things to consider. For one, a much higher number of gene counts of molecule counts may indicate the presence of doublets, especially for droplet-based scRNA-seq like 10X. In addition, high mitochondrial gene percentages may indicate dead cells, which is common in plate-based scRNA-seq like smart-seq.

***

```{r, tidy='styler', tidy.opts=list(strict=FALSE), fig.align='center'}
### add mito.gene % in meta.data
seurat_analysed[["percent.mt"]] <- PercentageFeatureSet(object = seurat_analysed, pattern = "^MT|^mt")

### Plot the three parameters mentioned above
pre_Vplot = VlnPlot(seurat_analysed, 
        pt.size = 0,
        features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), 
        ncol = 3) 

### Filter out cells that have QC metrics +/- away from 3*MAD:
### nFeature_RNA metric > 200-3*MAD(nFeature_RNA) and < median(nFeature_RNA)+3*MAD(nFeature_RNA)
### nCount_RNA < median(nCountRNA)+3*MAD(nCountRNA)
### percent.mt < median(percent.mt)+3*MAD(percent.mt)
seurat_analysed <- subset(x = seurat_analysed, 
                  subset = nFeature_RNA > max(params$qcs_std_nFeature_RNA, median(seurat_analysed@meta.data$nFeature_RNA, na.rm = TRUE) - 3*mad(seurat_analysed@meta.data$nFeature_RNA, constant = 1.4826, na.rm = TRUE))
                  & nFeature_RNA < median(seurat_analysed@meta.data$nFeature_RNA, na.rm = TRUE) + 3*mad(seurat_analysed@meta.data$nFeature_RNA, constant = 1.4826, na.rm = TRUE)
                  & nCount_RNA < median(seurat_analysed@meta.data$nCount_RNA, na.rm = TRUE) + 3*mad(seurat_analysed@meta.data$nCount_RNA, constant = 1.4826, na.rm = TRUE)
                  & percent.mt < median(seurat_analysed@meta.data$percent.mt, na.rm = TRUE) + 3*mad(seurat_analysed@meta.data$percent.mt, constant = 1.4826, na.rm = TRUE)
                  )

### re-plot
post_Vplot = VlnPlot(seurat_analysed, 
        pt.size=0,
        features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), 
        ncol = 3) 

cowplot::plot_grid(pre_Vplot, post_Vplot, nrow = 2, 
                   ncol = 1, labels = c("a) Prefilter", "b) Filtered"))
```

### Filter low count genes

There may be genes with zero counts across all cells too. 
These reduce the average expression for a cell and should be removed, as well. 
For our data we choose to keep only genes which are expressed in **`r params$qcs_ncells` or more cells**.

```{r, tidy='styler', tidy.opts=list(strict=FALSE)}
### Create the new seurat object
seurat_analysed <- CreateSeuratObject(seurat_analysed@assays$RNA@counts, 
                                      meta.data = seurat_analysed@meta.data, 
                                      min.cells = params$qcs_ncells, 
                                      min.features = params$qcs_nfeatures)
```

## 1.2 - Standardize

### Normalize the data

For data normalization, we use `NormalizeDatas()` that normalizes
the feature expression measurements for each cell by the total expression,
multiplies this by a scale factor (10,000 by default), 
and log-transforms the result. 
Normalized values are stored in **[["RNA"]]@data**.

```{r, tidy='styler', tidy.opts=list(strict=FALSE)}
seurat_analysed <- NormalizeData(seurat_analysed, 
                         normalization.method = "LogNormalize", 
                         scale.factor = 10000)
```

### Regress out confounding variables

Calculate a subset of features that exhibit high cell-to-cell variation 
in the dataset (i.e, they are highly expressed in some cells, and lowly 
expressed in others). These genes help to highlight biological signal in 
single-cell datasets.

By default, `FindVariableFeatures` returns 2,000 features per dataset, but can 
be changed to any number. 
These may be used in downstream analysis, like PCA.

***
**NOTE** 

This will be done for each tissue type individually, so make sure to run
through them one at a time.

***

```{r, tidy='styler', tidy.opts=list(strict=FALSE), fig.align='center', fig.cap="Variable features with labels. Identiy the 10 most highly variable genes."}
### Find the top 2000 most variable genes for PCA analysis
seurat_analysed <- FindVariableFeatures(object=seurat_analysed, selection.method = "vst", 
                            nfeatures = 2000)

### Plot variable features with labels
### Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(seurat_analysed), 10)
labels <- VariableFeaturePlot(seurat_analysed)
LabelPoints(plot = labels, points = top10, repel = TRUE)
```

### Scale the data 

Next, we apply a linear transformation (‘scaling’) that is a standard 
pre-processing step prior to dimensional reduction techniques like PCA. 
The `ScaleData()` function:

1. Shifts the expression of each gene, so that the mean expression across cells is 0
2. Scales the expression of each gene, so that the variance across cells is 1.
This step gives equal weight in downstream analyses, 
so that highly-expressed genes do not dominate
3. The results of this are stored in **[["RNA"]]@scale.data**
  
***
**NOTE** 

By default `ScaleData()` will only scale the identified 2,000 genes unless specified using the `"features = all.genes"` argument.

***

```{r, tidy='styler', tidy.opts=list(strict=FALSE)}
### Now scale
#all.genes <- rownames(x = seurat_analysed)
seurat_analysed <- ScaleData(object = seurat_analysed, 
#                     features = all.genes, 
                     verbose = FALSE,
                     vars.to.regress = unlist(strsplit(params$qcs_vars_regress, 
                                                       split = ",", fixed = T)))
```

## 1.3 - Identify the cell cycle phase for each cell
Score the cell cycle phase of each cell.
This is done by calculating the G2M marker score with the `CellCycleScoring()` function provided in the _seurat package_.

```{r}
### [1] Create G2M marker gene list (i.e. genes associated with the G2M phase of the 
### cell cycle using Seurat's built-in cc.genes (cell cycle) genes list
g2m.genes <- cc.genes$g2m.genes
g2m <- rownames(seurat_analysed)[rownames(seurat_analysed) %in% g2m.genes]

### [2] Calculate G2M marker module score.
seurat_analysed <- CellCycleScoring(seurat_analysed, 
                            s.features = cc.genes$s.genes, ### Genes associated with s-phase
                            g2m.features = g2m.genes, ### Genes associated with G2M phase
                            set.ident = TRUE)
```

## 1.4 - Write to file
The QC is done, the file is save on **_`r params$qcs_save_file`_**.

```{r, include=FALSE}
write_rds(seurat_analysed, file=params$qcs_save_file)
```
